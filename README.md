Опишите решение для веб-приложения в kubernetes в виде yaml-манифеста. Оставляйте в коде комментарии по принятым решениям. Есть следующие вводные:

1. У нас kubernetes кластер, в котором пять нод.
2. Приложение испытывает постоянную стабильную нагрузку в течение суток без значительных колебаний. 3 пода справляются с нагрузкой.
3. На первые запросы приложению требуется значительно больше ресурсов CPU, в дальнейшем потребление ровное в районе 0.1 CPU. По памяти всегда “ровно” в районе 128M memory.
4. Приложение требует около 5-10 секунд для инициализации.

Что хотим?

1. Минимальное потребление ресурсов от этого deployment’а.
2. Размещение подов на разных нодах для отказоустойчивости.
3. Чтобы под не обрабатывал запросы до завершения инициализации.
**************************************************************************************************************************************************
   [Uploading kubernetes.yaml…]()apiVersion: apps/v1
	kind: Deployment
	metadata:
	  name: test
	spec:
	  replicas: 3    #Установлено 3 реплики, так как это количество справляется с нагрузкой.         
	  selector:
	    matchLabels:
	      app: test
	template:
	    metadata:
	    labels:
	        app: test
	  strategy:
	    rollingUpdate:       # Используем стратегию rollingUpdate
	      maxSurge: 1        # На какое количество реплик можно увеличить, относительно "replicas: 1", при обновлении.
	      maxUnavailable: 0  # На какое количество реплик можно понизить, относительно "replicas: 1", при обновлении, в данном случае получается на 0, так как реплика одна.
	    type: RollingUpdate
	    spec:
	      containers:
	      - image: image.name
	        name: test
	        ports:
	        - containerPort: 80
	        readinessProbe:            # Проверят , готово ли приложения принимать трафик.
	          failureThreshold: 5      # Пять попыток для выполнения readinessProbe
	          httpGet:                 # Проверяет по http запросу, в корневой каталог, по 80 порту
	            path: /...             # Заменить на путь к health check вашего приложения
	            port: 80
	          periodSeconds: 10       # Проверяем каждый 10 секунд
	          successThreshold: 1     # Количество сбойных проверок
	          timeoutSeconds: 1       # timeout на выполнение нашей пробы
	        livenessProbe:            # Проверяет состояния приложения во время его жизни и перезагрузит под в случае ошибки
	          failureThreshold: 3
	          httpGet:                # Проверяет по http запросу, в корневой каталог, по порту
	            path: /...
	            port: 80
	          periodSeconds: 10       # Проверяем каждый 10 секунд
	          successThreshold: 1     # Количество сбойных проверок
	          timeoutSeconds: 1
	          initialDelaySeconds: 15 # После того как приложение запустилось, ждём 15 секунд, прежде чем выполнять livenessProbe.
	        resources:
	          requests:
	            cpu: "0.1"          #Не знаю, можно ли так писать
	            memory: 128Mi     #Потребление памяти
	          limits:
	            cpu: "1"         # Максимальное потребление ЦПУ пода
	            memory: 128Mi     # Максимальное потребление ОЗУ пода



******************************************************************************************************************


*************************************************************************************************************************************************
Наша абстракция service, чтобы принимать траффик
*************************************************************************************************************************************************
apiVersion: v1
kind: Service
metadata:
  name: test-service
spec:
  selector:
    app: test
  type: LoadBalancer             # Конфигурация нашего кластера
  ports:
    - port: 80                   # Порт сервиса
      targetPort: 80             # Порт приложения в контейнере
